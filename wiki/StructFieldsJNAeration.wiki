#summary Behaviour of JNAerator for struct fields
#labels Manual

= Arrays =

== Arrays with initializers ==
Arrays with initializers are converted to Java arrays :
 {{{
int iarr[4]; 
char* csarr[3][4]; 
char s[8];
}}}
becomes
 {{{
public final int[] iarr = new int[(4)];
public final com.sun.jna.ptr.ByteByReference[] csarr = new com.sun.jna.ptr.ByteByReference[3 * 4];
public final byte[] s = new byte[(8)];
}}}

== Arrays with partial initializers ==

When an array has partial size initializers, JNAerator initializes the known part and switches to Pointer for the rest of the type :
 {{{
char *(*(**foo[][8])())[];
long* (*foo2[12][8])();
}}}
becomes
 {{{
public final com.sun.jna.Pointer[] foo = new com.sun.jna.Pointer[8];
public final foo2_callback[] foo2 = new foo2_callback[12 * 8];
public interface foo2_callback extends com.sun.jna.Callback {
	com.sun.jna.ptr.NativeLongByReference callback();
}
}}}

= Callbacks =

 {{{
long (__cdecl *const fptr)();
void (*functions[8])(void*);
}}}
becomes
 {{{
public fptr_callback fptr;
public final functions_callback[] functions = new functions_callback[(8)];
public interface fptr_callback extends com.sun.jna.Callback {
	com.sun.jna.NativeLong callback();
}
public interface functions_callback extends com.sun.jna.Callback {
	void callback(com.sun.jna.Pointer arg1);
}
}}}

= Structs =

 {{{
struct A {
    int i;
};
struct B {
   A a;
   A *pa;
};
}}}
naturally becomes :
 {{{
	public static class A extends com.sun.jna.Structure {
		public static class ByReference extends A implements com.sun.jna.Structure.ByReference {}
		public static class ByValue extends A implements com.sun.jna.Structure.ByValue {}
		public int i;
	}

	public static class B extends com.sun.jna.Structure {
		public static class ByReference extends B implements com.sun.jna.Structure.ByReference {}
		public static class ByValue extends B implements com.sun.jna.Structure.ByValue {}
		public A.ByValue a;
		public A pa;
	}
}}}