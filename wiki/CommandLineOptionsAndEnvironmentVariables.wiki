#summary JNAerator's command-line options & environment variables
#sidebar sidebar

= Syntax =

{{{ java -jar jnaerator.jar options headerFiles dynamicLibrariesFiles }}}

= Options =

 * *@(.+)?* <argumentsFile.jnaerator: ExistingFile>
  Read command-line arguments from a file. File may contain multiple lines (those beginning with "//" will be skipped), file wildcards will be resolved within the file content, as well as variables substitutions : $(someEnvOrJavaVarName), with $(DIR) being the parent directory of the current arguments file.
 * *-o* <outDir: OutputDir>
  Output directory for all artifacts
 * *-scanSymbols*
  Extract, unmangle and parse the symbols all listed shared libraries
 * *-I(.+)?* <dir: File>
  Add a directory to the include path. See doc of JNAERATOR_INCLUDE_PATH
 * *-F(.+)?* <dir: File>
  Add a directory to the frameworks path. See doc of JNAERATOR_FRAMEWORKS_PATH
 * *-frameworksPath* <path1:path2...: String>
  See doc of JNAERATOR_FRAMEWORKS_PATH
 * *-framework* <frameworkName: String>
  JNAerate a framework using its headers and its *.bridgesupport files if available
 * *-limitComments*
  Avoid useless comments (source file + line, skipped items...)
 * *-nocpp*
  Do not define the __cplusplus symbol
 * *-gui*
  Show minimalist progression GUI
 * *-noRuntime*
  Don't copy runtime classes to JAR output
 * *-jar* <outFile: OutputFile>
  Jar file where all generated sources and the compiled classes go
 * *-test*
  Launch JNAerator's unit tests (DEBUG option)
 * *-studio*
  Launch JNAeratorStudio
 * *-project* <solutionFile: ExistingFile> <"Config|Platform": String>
  Read Visual Studio 2008 project or solution file and use the configuration specified (e.g. "Release|Win32").
 * *-noAuto*
  No auto-configuration of preprocessor symbols and paths
 * *-direct*
  JNAerate libraries that use JNA's faster direct call convention
 * *-preferJavac*
  Use Sun's Javac compiler instead of Eclipse's ecj, if possible
 * *-structsInLibrary*
  Force structs to be JNAerated as inner classes of their declaring libraries (otherwise, each top-level structure is defined as a top-level class in its library's package)
 * *-package* <forcedPackageName: String>
  Set the Java package in which all the output will reside (by default, set to the library name).
 * *-D([^=]*)(?:=(.*))?* <name: String> <value: String>
  Define a macro symbol
 * *-root(?:Package)?* <package: String>
  Define the root package for all output classes
 * *-library* <libName: String>
  Define the name of the output library. This is a state parameter, it will affect all files listed after it, until another -library switch is provided. It does not affect sources included from a project file (Visual Studio...).
C functions exported in library "test" will end up in class "TestLibrary", for instance. 
The name of the library is the one fed to JNA to find the shared library, so library "test" must be in "test.dll" on Windows, "libtest.dylib" on Mac OS X and  "libtest.so" on other Unices.
Note that a special hack is done for library "c" on Windows systems : the output name is set to "msvcrt" instead of "c".

 * *-defaultLibrary* <libName: String>
  Name of output library for elements declared in files not covered by a ${CurrentLibrary} switch
 * *-h(?:elp)?*
  Show command line arguments help
 * *-entryClass* <entryClassName: String>
  Generate a class _entryclassName.EntryClassName_ that will contain all of the jnaerated libraries instances. User code will just need to static import or derive from this class to access to the instances.
 * *-v(?:erbose)?*
  Verbose output (both console and files)
 * *-preprocessingOut* <outFile: OutputFile>
  Write the preprocessor output in a file (automatically set when ${Verbose} is used).
 * *-wikiHelp*
  Output a wiki-friendly help
 * *-arch* <archName: String>
  Define the current architecture for libraries (state variable)
 * *-macrosOut* <outFile: OutputFile>
  Write the preprocessor macros in a file (automatically set when ${Verbose} is used).
 * ** <file: OptionalFile>
  Any header (or directory containing headers at any level of hierarchy), shared library, *.bridgesupport file or *.jnaerator file


= Environment Variables =

All of these variables may be overridden by setting the environment variable ({{{ set VAR=value }}} on Windows, {{{ export VAR=value }}} on most unices) or through Java properties ({{{ java -DVAR=value -jar jnaerator.jar ... }}}).

 * VISUAL_STUDIO_HOME = 
   {{{ 
C:\Program Files\Microsoft Visual Studio 9.0 
   }}}
 * WINDOWS_SDK_HOME
   {{{ 
C:\Program Files\Microsoft SDKs\Windows\v6.0A
   }}}
 * VISUAL_STUDIO_INCLUDES = VISUAL_STUDIO_HOME;WINDOWS_SDK_HOME
 * JNAERATOR_INCLUDE_PATH : has the following platform-dependent default values :
   * Windows : uses VISUAL_STUDIO_INCLUDES
   * Mac OS X : {{{ /Developer/SDKs/MacOSX10.4u.sdk/usr/include:. }}}
   * Current dir on any other platform

 * JNAERATOR_FRAMEWORKS_PATH is only set on Mac OS X : 
   {{{
/System/Library/Frameworks/CoreServices.framework/Versions/Current/Frameworks:\
/System/Library/Frameworks/ApplicationServices.framework/Versions/Current/Frameworks:\
/System/Library/Frameworks:\
/Library/Frameworks:\
~/Library/Frameworks 
   }}}